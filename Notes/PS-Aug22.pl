// Software developer process
Methods {
    waterfall model;
    spiral model;
    RUDE; // run, understand, debug, edit
}

Why study PL concepts?
    1.Increased capacity to express ideas {
        Use comments, programmer discipline, recursive algs, initialize variables, member functions;
    };

    2.Improved background for choosing appropiate languages {
        - simplicity, readability, reliability, support, abstraction, orthogonality, efficient implementation, clarity abt bindings 
            * simplicity and readability
                - small instruction set (java vs scheme)
                - simple syntax (C/C++/Java vs python)
                - benefits: ease of learning and ease of programming
            * clarity about binding 
                - binding is the association between an object and a property of that object (ex - variable and variable type)
                - early binding takes place at compile time 
                - late binding takes place at run time 
            * reliability
                - program behavior is the same on different platforms (early versions of Fortran)
                - type errors are detected (C vs haskell)
                - semantic errors are properly trapped (Java vs C++)
                - memory leaks are prevented (C vs Java)
                - ex
                    if (x = 2) {
                         // legal in c++, implicit conversion = to ==
                        // illegal in java, explicity use ==
                    }
            * language support 
                - accessible (public domain) compilers/interpretors
                - good texts and tutorials
                - wide community of users
                - intergrated with development environments (IDEs)
            * abstraction in programming
                - date 
                    - programmer defined types/classes
                    - class libraries
                - procedural
                    - programmer defined functions
                    - standard function libraries
            * orthogonality
                - if its features are built upon a small, mutually independednt set of primitive operations
                    - fewer exceptional rules = conceptual simplicity
                    - tradeoffs with efficiency
            * efficent implementation
                - embedded sys 
                    -real-time responsiveness (e.g. naviagation)
                    -failures of early Ada implementations
                - web apps 
                    - responsiveness to users (e.g google search)
                - corporate database apps 
                    - efficient search and updating
                - AI apps
                    - modeling human behaviors
    };

    3.Increastd abiliity to learn new languages {};
    4.Better understanding of the signifigance of implementation {};
    5.Increased ability to design new languages {};
    6.Background for compiler writing {};
    7.Overall advancement of computing {};

Software developer process
    Methods {
        waterfall model;
        spiral model;
        RUDE; // run, understand, debug, edit
    };

Languages 
    Ada {
        #3 backing of a powerful sponsor

    };
    Apl {
        #3 easy to express things, easy to use once fluent, "powerful"
    };
    Algol-68 {
        #3 easy to express things, easy to use once fluent, "powerful"
    };
    Basic {
        #3 easy to learn
        #3 easy to implement

    };
    CSP {
        #1 lack of recursion
    };
    Cobol {
        #3 backing of a powerful sponsor
    };
    Common Lisp {
        #3 easy to express things, easy to use once fluent, "powerful"

    };
    C/C++ {
        #1 lack of modules
        #3 easy to express things, easy to use once fluent, "powerful"
        #3 possible to compile very good (fast/small) code
    };
    Forth {
        #3 easy to implement
    };
    Fortran {
        #1 lack of suitable control structures
        #1 lack of recursion
        #1 lack of named constants and enumerations
        #3 possible to compile very good (fast/small) code
    };
    Hackshell {
        #3 easy to express things, easy to use once fluent, "powerful"

    };
    Java {
        #3 wide dissemination at minimal cost

    };
    Logo {
        #3 easy to learn

    };
    Pascal {
        #1 lack of modules
        #3 easy to learn
        #3 wide dissemination at minimal cost
    };
    Perl {
        #3 easy to express things, easy to use once fluent, "powerful"

    };
    Pl/1 {
        #3 backing of a powerful sponsor
    };
    Python {
        #3 easy to learn
        #3 wide dissemination at minimal cost
    };
    Scheme {
        #3 easy to learn

    };
    Turig {
        #3 wide dissemination at minimal cost

    };
    Visual Basic {
        #3 backing of a powerful sponsor

    };
